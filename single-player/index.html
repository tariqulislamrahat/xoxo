<!-- BY: Tariqul Islam -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XOXO</title>
    <link rel="icon" href="../img/bar.svg">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: url('../img/bg.svg') no-repeat center center fixed;
            background-size: cover;
            font-family: 'Orbitron', sans-serif;
            color: #ffffff;
            animation: fadeIn 1s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-container {
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            transition: box-shadow 0.5s ease;
        }

        .game-container:hover {
            box-shadow: 0 20px 35px rgba(0, 0, 0, 0.7);
        }

        .player-turn {
            font-size: 1.8rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: color 0.3s ease;
        }

        .player-turn span {
            color: #ff002b;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            justify-content: center;
        }

        .cell {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: #ffffff;
            border: 3px solid #00d0ff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px;
            animation: popIn 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        @keyframes popIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .cell:hover {
            background: #f0f0f0;
            transform: scale(1.05);
            box-shadow: 0 0 10px #00d0ff;
        }

        .cell.x, .cell.o {
            animation: markAppear 0.5s ease;
        }

        @keyframes markAppear {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        .cell.x {
            color: #00d0ff;
            text-shadow: 0 0 10px #00d0ff;
        }

        .cell.o {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        .cell.will-remove {
            border: 3px solid rgba(255, 255, 0, 0.6);
            animation: pulseWarning 1.5s ease-in-out infinite;
        }

        @keyframes pulseWarning {
            0%, 100% {
                border-color: rgba(255, 255, 0, 0.6);
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.3);
            }
            50% {
                border-color: rgba(255, 255, 0, 1);
                box-shadow: 0 0 0 6px rgba(255, 255, 0, 0);
            }
        }

        .cell.removing {
            animation: fadeOut 0.6s ease forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.5); }
        }

        .player-info {
            margin-top: 20px;
            color: white;
        }

        .reset-btn {
            background: #ff002b;
            border: 3px solid #00d0ff;
            color: #ffffff;
            padding: 10px 20px;
            font-size: 1rem;
            font-family: 'Orbitron', sans-serif;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .reset-btn:hover {
            background: #ff0000;
            transform: scale(1.05);
            box-shadow: 0 0 10px #ff0000;
        }

        .winner-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            display: none;
            width: 80%;
            max-width: 400px;
            animation: popUp 0.5s ease;
        }

        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }

        @keyframes popUp {
            from { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .credit {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ffffff;
            text-align: center; 
        }

        .credit a {
            color: #ff0000;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .credit a:hover {
            color: #00d0ff;
            text-decoration: underline;
        }

        @media (min-width: 768px) {
            .player-turn {
                font-size: 2rem;
            }

            .cell {
                font-size: 3.5rem;
            }

            .reset-btn {
                font-size: 1.2rem;
            }

            .winner-message {
                font-size: 1.2rem;
            }
        }

        @media (min-width: 1024px) {
            .game-container {
                padding: 40px;
            }

            .player-turn {
                font-size: 2.2rem;
            }

            .cell {
                font-size: 4rem;
            }

            .reset-btn {
                font-size: 1.4rem;
                padding: 12px 24px;
            }

            .winner-message {
                font-size: 1.4rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="player-turn"><span id="currentPlayer">X</span>'s Turn</div>
        <div class="board" id="board"></div><br>
        <button class="reset-btn" onclick="resetGame()">RESET</button>
    </div>
    
    <div class="credit">PLAY: <a href="https://tariqulislamrahat.github.io/xoxo/">MULTI PLAYER</a></div>

    <div id="winnerOverlay" class="winner-overlay" onclick="resetGame()"></div>
    <div id="winnerMessage" class="winner-message">
        <h2 id="winnerText"></h2>
        <button class="reset-btn" onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const BOARD_SIZE = 9;
        const MAX_MOVES_PER_PLAYER = 3;
        const MAX_DEPTH = 10;
        let currentPlayer = 'x';
        let board = Array(BOARD_SIZE).fill(null);
        let xMoves = [];
        let oMoves = [];
        let gameOver = false;
        let isAnimating = false;
        let moveCount = 0;

        const winPatterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        // Positional weights: center > corners > edges
        const POSITION_WEIGHTS = [3, 2, 3, 2, 5, 2, 3, 2, 3];

        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            for (let i = 0; i < BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.setAttribute('data-index', i);
                cell.addEventListener('click', handleCellClick);
                boardElement.appendChild(cell);
            }
        }

        function handleCellClick(event) {
            if (currentPlayer !== 'x' || gameOver || isAnimating) return;
            const index = parseInt(event.target.getAttribute('data-index'));
            if (board[index]) return;

            const removed = placeMove(index);
            if (gameOver) return;

            if (removed) {
                setTimeout(aiMove, 700);
            } else {
                setTimeout(aiMove, 300);
            }
        }

        function placeMove(index) {
            board[index] = currentPlayer;
            const cell = document.querySelector(`[data-index="${index}"]`);
            cell.classList.remove('x', 'o', 'removing', 'will-remove');
            cell.textContent = currentPlayer.toUpperCase();
            cell.classList.add(currentPlayer);

            const removed = trackPlayerMoves(index);
            moveCount++;

            if (checkWinForMoves(currentPlayer === 'x' ? xMoves : oMoves)) {
                showWinner(currentPlayer);
                gameOver = true;
            } else if (moveCount > 30 && isDrawState()) {
                showDraw();
                gameOver = true;
            }

            switchPlayer();
            updateWillRemoveVisuals();
            return removed;
        }

        function trackPlayerMoves(index) {
            const movesArray = currentPlayer === 'x' ? xMoves : oMoves;
            movesArray.push(index);
            let removed = false;

            if (movesArray.length > MAX_MOVES_PER_PLAYER) {
                removed = true;
                isAnimating = true;
                const oldestMove = movesArray.shift();
                const oldestCell = document.querySelector(`[data-index="${oldestMove}"]`);
                oldestCell.classList.add('removing');
                board[oldestMove] = null;
                setTimeout(() => {
                    oldestCell.textContent = '';
                    oldestCell.classList.remove('x', 'o', 'removing', 'will-remove');
                    isAnimating = false;
                }, 600);
            }
            return removed;
        }

        function updateWillRemoveVisuals() {
            document.querySelectorAll('.will-remove').forEach(el => el.classList.remove('will-remove'));
            if (gameOver) return;

            if (xMoves.length === MAX_MOVES_PER_PLAYER) {
                const nextToRemove = document.querySelector(`[data-index="${xMoves[0]}"]`);
                if (nextToRemove) nextToRemove.classList.add('will-remove');
            }
            if (oMoves.length === MAX_MOVES_PER_PLAYER) {
                const nextToRemove = document.querySelector(`[data-index="${oMoves[0]}"]`);
                if (nextToRemove) nextToRemove.classList.add('will-remove');
            }
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'x' ? 'o' : 'x';
            document.getElementById('currentPlayer').textContent = currentPlayer.toUpperCase();
        }

        function checkWinForMoves(moves) {
            if (moves.length < 3) return false;
            return winPatterns.some(pattern => pattern.every(index => moves.includes(index)));
        }

        function showWinner(player) {
            const winnerMessage = document.getElementById('winnerMessage');
            const winnerOverlay = document.getElementById('winnerOverlay');
            const winnerText = document.getElementById('winnerText');
            winnerText.textContent = player === 'x' ? 'You Win! ðŸŽ‰' : 'AI Wins! ðŸ¤–';
            winnerMessage.style.display = 'block';
            winnerOverlay.style.display = 'block';
            gameOver = true;
        }

        function showDraw() {
            const winnerMessage = document.getElementById('winnerMessage');
            const winnerOverlay = document.getElementById('winnerOverlay');
            const winnerText = document.getElementById('winnerText');
            winnerText.textContent = "It's a Draw! ðŸ¤";
            winnerMessage.style.display = 'block';
            winnerOverlay.style.display = 'block';
            gameOver = true;
        }

        // Detect repeated board states indicating a draw
        let stateHistory = [];
        function isDrawState() {
            const stateKey = getBoardStateKey(xMoves, oMoves);
            const occurrences = stateHistory.filter(s => s === stateKey).length;
            return occurrences >= 3;
        }

        function getBoardStateKey(xM, oM) {
            return [...xM].sort().join(',') + '|' + [...oM].sort().join(',');
        }

        function resetGame() {
            board = Array(BOARD_SIZE).fill(null);
            currentPlayer = 'x';
            xMoves = [];
            oMoves = [];
            gameOver = false;
            isAnimating = false;
            moveCount = 0;
            stateHistory = [];

            document.getElementById('currentPlayer').textContent = 'X';
            document.getElementById('winnerMessage').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'none';
            createBoard();
        }

        // =============================================
        //  IMPROVED AI: Minimax + Alpha-Beta Pruning
        //  with removal-aware heuristics, fork detection,
        //  blocking, and cycle detection
        // =============================================

        function aiMove() {
            if (gameOver || isAnimating) {
                if (isAnimating) setTimeout(aiMove, 100);
                return;
            }
            const move = findBestMove();
            if (move !== undefined) {
                placeMove(move);
            }
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove;
            const empties = getEmpty(xMoves, oMoves);

            // Try immediate winning move first (optimization)
            for (let pos of empties) {
                let simOM = [...oMoves, pos];
                if (simOM.length > MAX_MOVES_PER_PLAYER) simOM.shift();
                if (checkWinForMoves(simOM)) return pos;
            }

            // Then block opponent's immediate winning move
            for (let pos of empties) {
                let simXM = [...xMoves, pos];
                if (simXM.length > MAX_MOVES_PER_PLAYER) simXM.shift();
                if (checkWinForMoves(simXM)) return pos;
            }

            // Full minimax search
            const visited = new Set();
            for (let pos of empties) {
                let simOM = [...oMoves, pos];
                if (simOM.length > MAX_MOVES_PER_PLAYER) simOM.shift();
                const score = minimax([...xMoves], simOM, false, 0, -Infinity, Infinity, visited);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = pos;
                }
            }
            return bestMove;
        }

        function minimax(xM, oM, isMaximizing, depth, alpha, beta, visited) {
            // Terminal checks
            if (checkWinForMoves(oM)) return 1000 - depth;
            if (checkWinForMoves(xM)) return -1000 + depth;
            if (depth >= MAX_DEPTH) return evaluate(xM, oM);

            // Cycle detection
            const stateKey = getBoardStateKey(xM, oM) + (isMaximizing ? ':max' : ':min');
            if (visited.has(stateKey)) return 0; // Draw by repetition
            visited.add(stateKey);

            const empties = getEmpty(xM, oM);

            if (isMaximizing) {
                // AI (O) is maximizing
                let maxScore = -Infinity;
                for (let pos of empties) {
                    let newOM = [...oM, pos];
                    if (newOM.length > MAX_MOVES_PER_PLAYER) newOM.shift();
                    let score = minimax([...xM], newOM, false, depth + 1, alpha, beta, visited);
                    maxScore = Math.max(maxScore, score);
                    alpha = Math.max(alpha, score);
                    if (beta <= alpha) break;
                }
                visited.delete(stateKey);
                return maxScore;
            } else {
                // Player (X) is minimizing
                let minScore = Infinity;
                for (let pos of empties) {
                    let newXM = [...xM, pos];
                    if (newXM.length > MAX_MOVES_PER_PLAYER) newXM.shift();
                    let score = minimax(newXM, [...oM], true, depth + 1, alpha, beta, visited);
                    minScore = Math.min(minScore, score);
                    beta = Math.min(beta, score);
                    if (beta <= alpha) break;
                }
                visited.delete(stateKey);
                return minScore;
            }
        }

        function evaluate(xM, oM) {
            // Check for wins first (shouldn't reach here normally, but safety)
            if (checkWinForMoves(oM)) return 1000;
            if (checkWinForMoves(xM)) return -1000;

            let score = 0;

            // 1. Line-based scoring
            score += evaluateLines(oM, xM); // AI advantage
            score -= evaluateLines(xM, oM); // Player advantage

            // 2. Positional scoring
            score += getPositionalScore(oM) * 0.5;
            score -= getPositionalScore(xM) * 0.5;

            // 3. Fork detection (multiple threats)
            score += countThreats(oM, xM) * 15;
            score -= countThreats(xM, oM) * 15;

            // 4. Removal awareness â€” penalize if a key piece is about to be removed
            score += getRemovalPenalty(oM, xM);
            score -= getRemovalPenalty(xM, oM);

            return score;
        }

        function evaluateLines(myMoves, oppMoves) {
            let score = 0;
            for (let pattern of winPatterns) {
                let myCount = 0;
                let oppCount = 0;
                for (let idx of pattern) {
                    if (myMoves.includes(idx)) myCount++;
                    if (oppMoves.includes(idx)) oppCount++;
                }

                if (oppCount === 0) {
                    // Unblocked line
                    if (myCount === 3) score += 100;
                    else if (myCount === 2) score += 10;
                    else if (myCount === 1) score += 2;
                } else if (myCount === 0) {
                    // Opponent's line â€” we should value blocking
                    if (oppCount === 2) score -= 3; // Incentive to block
                }
            }
            return score;
        }

        function getPositionalScore(moves) {
            let score = 0;
            for (let m of moves) {
                score += POSITION_WEIGHTS[m];
            }
            return score;
        }

        function countThreats(myMoves, oppMoves) {
            let threats = 0;
            for (let pattern of winPatterns) {
                let myCount = 0;
                let oppCount = 0;
                for (let idx of pattern) {
                    if (myMoves.includes(idx)) myCount++;
                    if (oppMoves.includes(idx)) oppCount++;
                }
                if (myCount === 2 && oppCount === 0) threats++;
            }
            return threats;
        }

        function getRemovalPenalty(myMoves, oppMoves) {
            if (myMoves.length < MAX_MOVES_PER_PLAYER) return 0;

            // The oldest move (index 0) will be removed next
            const willRemove = myMoves[0];
            let penalty = 0;

            // Check if the piece about to be removed is part of a valuable pattern
            for (let pattern of winPatterns) {
                if (!pattern.includes(willRemove)) continue;
                let myCount = 0;
                let oppCount = 0;
                for (let idx of pattern) {
                    if (myMoves.includes(idx)) myCount++;
                    if (oppMoves.includes(idx)) oppCount++;
                }
                // If removing this piece breaks a strong line
                if (myCount === 2 && oppCount === 0) penalty -= 8;
                if (myCount === 3 && oppCount === 0) penalty -= 20;
            }

            // Penalty for losing a center piece
            if (willRemove === 4) penalty -= 4;
            // Penalty for losing a corner
            if ([0, 2, 6, 8].includes(willRemove)) penalty -= 2;

            return penalty;
        }

        function getEmpty(xM, oM) {
            const occupied = new Set([...xM, ...oM]);
            let emp = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                if (!occupied.has(i)) emp.push(i);
            }
            return emp;
        }

        // Track states for draw detection
        function recordState() {
            stateHistory.push(getBoardStateKey(xMoves, oMoves));
        }

        // Wrap placeMove to also record state
        const originalPlaceMove = placeMove;
        // Instead, we record state inside the placeMove flow via a hook after move completes

        const origHandleCellClick = handleCellClick;

        createBoard();
    </script>
</body>
</html>
